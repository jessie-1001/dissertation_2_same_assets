# =============================================================================
# SCRIPT 04: BACKTESTING AND ANALYSIS (FINAL CORRECTED VERSION)
#
# Description:
# This script evaluates the performance of the GARCH-Copula models by:
# 1. Loading the forecasts generated by SCRIPT 03.
# 2. Performing statistical backtests on the 99% VaR (Kupiec POF, Christoffersen).
# 3. Performing backtests on the 99% ES.
# 4. Conducting stress tests over specific crisis periods (e.g., COVID-19).
# 5. Visualizing the model's performance and the dependence structure of the assets
#    using the full dataset's PIT-transformed values.
# =============================================================================

import pandas as pd
import numpy as np
from scipy import stats
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib as mpl

# --- Global Settings ---
warnings.filterwarnings("ignore")
plt.style.use('seaborn-v0_8-darkgrid')
mpl.rcParams['font.family'] = 'DejaVu Sans'
mpl.rcParams['axes.unicode_minus'] = False
mpl.rcParams['figure.dpi'] = 100

# -----------------------------------------------------------------------------
# 1. STATISTICAL BACKTESTING FUNCTIONS
# -----------------------------------------------------------------------------

def kupiec_pof_test(hits, alpha=0.01):
    n = len(hits)
    n1 = hits.sum()
    if n == 0: return 0, np.nan, 1.0
    p = alpha
    pi_hat = n1 / n
    if n1 == 0 or np.isclose(pi_hat, 0):
        log_lr = -2 * (n * np.log(1 - p))
    elif np.isclose(pi_hat, 1.0):
        log_lr = -2 * (n * np.log(p))
    else:
        log_lr = 2 * (n1 * np.log(pi_hat / p) + (n - n1) * np.log((1 - pi_hat) / (1 - p)))
    p_value = 1 - stats.chi2.cdf(log_lr, df=1)
    return n1, log_lr, p_value

def christoffersen_test(hits):
    n00, n01, n10, n11 = 0, 0, 0, 0
    for i in range(1, len(hits)):
        if hits.iloc[i-1] == 0 and hits.iloc[i] == 0: n00 += 1
        elif hits.iloc[i-1] == 0 and hits.iloc[i] == 1: n01 += 1
        elif hits.iloc[i-1] == 1 and hits.iloc[i] == 0: n10 += 1
        elif hits.iloc[i-1] == 1 and hits.iloc[i] == 1: n11 += 1
    if (n00 + n01 + n10 + n11) == 0: return np.nan, np.nan
    pi0 = n01 / (n00 + n01) if (n00 + n01) > 0 else 0
    pi1 = n11 / (n10 + n11) if (n10 + n11) > 0 else 0
    pi = (n01 + n11) / (n00 + n01 + n10 + n11)
    if np.isclose(pi, 0) or np.isclose(pi, 1): return np.nan, np.nan
    log_L0 = (n00 + n10) * np.log(1 - pi) + (n01 + n11) * np.log(pi)
    log_L1 = 0
    if pi0 > 0 and pi0 < 1: log_L1 += n00 * np.log(1 - pi0) + n01 * np.log(pi0)
    if pi1 > 0 and pi1 < 1: log_L1 += n10 * np.log(1 - pi1) + n11 * np.log(pi1)
    if np.isinf(log_L1): return np.nan, np.nan
    stat = -2 * (log_L0 - log_L1)
    pval = 1 - stats.chi2.cdf(stat, df=1)
    return stat, pval

def bayer_scheule_es_test(realized, es_series, var_series):
    breaches = realized <= var_series
    n_breaches = breaches.sum()
    if n_breaches < 20:
        return np.nan, np.nan, "Insufficient Data"
    exceedances = realized[breaches] / es_series[breaches] - 1
    t_stat, p_value = stats.ttest_1samp(exceedances, 0, nan_policy='omit')
    result = "Pass" if p_value > 0.05 else "Reject"
    return t_stat, p_value, result

# -----------------------------------------------------------------------------
# 2. ANALYSIS AND VISUALIZATION ROUTINES
# -----------------------------------------------------------------------------

def perform_full_backtest(forecast_df, actual_df, models, alpha=0.01):
    results = []
    for model in models:
        weights = forecast_df[[f"{model}_Weight_SPX", f"{model}_Weight_DAX"]]
        actual_returns_oos = actual_df.loc[weights.index]
        realized = (actual_returns_oos[["SPX_Return", "DAX_Return"]] * weights.values).sum(axis=1)
        var_series = forecast_df.loc[weights.index, f"{model}_VaR_99"]
        es_series = forecast_df.loc[weights.index, f"{model}_ES_99"]
        merged = pd.concat([realized, var_series, es_series], axis=1).dropna()
        hits = (merged.iloc[:, 0] <= merged.iloc[:, 1]).astype(int)
        n_breaches, _, kupiec_pval = kupiec_pof_test(hits, alpha=alpha)
        _, christ_pval = christoffersen_test(hits)
        expected = len(hits) * alpha
        es_stat, es_pval, es_result = bayer_scheule_es_test(merged.iloc[:, 0], merged.iloc[:, 2], merged.iloc[:, 1])
        results.append({
            "Model": model, "VaR Breaches": f"{n_breaches} (Exp: {expected:.1f})",
            "Kupiec p-val": kupiec_pval, "Christoffersen p-val": christ_pval,
            "ES t-stat": es_stat, "ES p-val": es_pval, "ES Result": es_result,
        })
    return pd.DataFrame(results)

def plot_dependence_structure(data, period_range=None, period_name="Full Sample", file_suffix=""):
    data = data.sort_index()

    if period_range:
        start, end = pd.to_datetime(period_range[0]), pd.to_datetime(period_range[1])
        sub_data = data.loc[start:end]
    else:
        sub_data = data
        
    print(f"Plotting dependence for '{period_name}' with {len(sub_data)} data points.")
    if sub_data.empty:
        print(f"--> WARNING: No data available for {period_name}. Skipping plot.")
        return

    fig, axes = plt.subplots(1, 2, figsize=(14, 6))
    fig.suptitle(f"Dependence Structure: {period_name} ({len(sub_data)} days)", fontsize=16)
    u_spx, u_dax = sub_data['u_spx'], sub_data['u_dax']
    hb = axes[0].hexbin(u_spx, u_dax, gridsize=30, cmap='viridis', mincnt=1)
    fig.colorbar(hb, ax=axes[0], label='Data Point Density')
    axes[0].set_title("Joint Distribution of PITs")
    axes[0].set_xlabel("SPX PIT")
    axes[0].set_ylabel("DAX PIT")
    axes[0].set_aspect('equal', adjustable='box')
    axes[1].scatter(u_spx, u_dax, alpha=0.3, s=10, color='red')
    axes[1].set_title("Lower Tail Dependence (Zoomed)")
    axes[1].set_xlabel("SPX PIT")
    axes[1].set_ylabel("DAX PIT")
    axes[1].set_xlim(0, 0.1)
    axes[1].set_ylim(0, 0.1)
    axes[1].set_aspect('equal', adjustable='box')
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.savefig(f"dependence_structure_{file_suffix}.png", dpi=300)
    plt.close()
    print(f"--> Saved dependence plot: dependence_structure_{file_suffix}.png")

# -----------------------------------------------------------------------------
# 3. MAIN EXECUTION BLOCK
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("\n" + "="*80)
    print(">>> SCRIPT 04: BACKTESTING AND ANALYSIS <<<")
    
    try:
        print("\nLoading data files...")
        forecast_df = pd.read_csv("garch_copula_forecasts_improved.csv", index_col='Date', parse_dates=True)
        actual_df = pd.read_csv("spx_dax_daily_data.csv", index_col='Date', parse_dates=True)
        copula_data_for_viz = pd.read_csv('copula_input_data_full.csv', index_col='Date', parse_dates=True)

        # <<< FIX: Correctly convert index to datetime and then remove timezone >>>
        forecast_df.index = pd.to_datetime(forecast_df.index).tz_localize(None)
        actual_df.index = pd.to_datetime(actual_df.index).tz_localize(None)
        copula_data_for_viz.index = pd.to_datetime(copula_data_for_viz.index).tz_localize(None)

        print("Data loading complete.")
        print(f"  Forecasts loaded: {len(forecast_df)} days")
        print(f"  Actual returns loaded: {len(actual_df)} days")
        print(f"  PIT data for visualization loaded: {len(copula_data_for_viz)} days")

    except FileNotFoundError as e:
        print(f"\n[ERROR] File not found: {e.filename}. Please run previous scripts first.")
        exit()

    print("\n" + "-"*80)
    print(">>> VaR and ES Backtesting Summary <<<")
    models_to_test = ["Gaussian", "StudentT", "Gumbel", "Clayton"]
    summary_table = perform_full_backtest(forecast_df, actual_df, models_to_test)
    print(summary_table.to_markdown(index=False, floatfmt=".4f"))
    summary_table.to_csv("backtesting_summary_final.csv", index=False)
    print("\nBacktesting summary saved to 'backtesting_summary_final.csv'.")
    print("-" * 80)
    
    print("\n" + "-"*80)
    print(">>> Generating Dependence Structure Visualizations <<<")
    crisis_periods = {
        "COVID-19 Crash": ("2020-02-19", "2020-04-07"),
        "2023 Banking Crisis": ("2023-03-08", "2023-03-24")
    }
    
    oos_indices = forecast_df.index.intersection(copula_data_for_viz.index)
    plot_dependence_structure(copula_data_for_viz.loc[oos_indices], 
                              period_name="Full Out-of-Sample Period", 
                              file_suffix="full_oos")

    for name, period in crisis_periods.items():
        plot_dependence_structure(copula_data_for_viz, 
                                  period_range=period, 
                                  period_name=name, 
                                  file_suffix=name.lower().replace(" ", "_"))
    print("-" * 80)

    best_model = 'StudentT'
    print(f"\n>>> Generating VaR Breach Plot for '{best_model}' Model <<<")
    
    weights = forecast_df[[f"{best_model}_Weight_SPX", f"{best_model}_Weight_DAX"]]
    actual_returns_oos = actual_df.loc[weights.index]
    realized_returns = (actual_returns_oos[["SPX_Return", "DAX_Return"]] * weights.values).sum(axis=1)
    var_series = forecast_df.loc[weights.index, f"{best_model}_VaR_99"]
    merged = pd.concat([realized_returns, var_series], axis=1).dropna()
    breaches = merged.iloc[:, 0] <= merged.iloc[:, 1]
    
    plt.figure(figsize=(15, 7))
    plt.plot(merged.index, merged.iloc[:, 0], label='Portfolio Realized Return', color='gray', alpha=0.7, linewidth=1)
    plt.plot(merged.index, merged.iloc[:, 1], label=f'{best_model} 99% VaR Forecast', color='blue', linestyle='--', linewidth=1.5)
    plt.scatter(merged.index[breaches], merged.iloc[:, 0][breaches], color='red', s=50, zorder=5, label=f'VaR Breaches ({breaches.sum()})')
    plt.title(f'VaR Backtest for {best_model}-Copula Model', fontsize=16)
    plt.ylabel('Portfolio Return (%)')
    plt.xlabel('Date')
    plt.legend()
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    plt.tight_layout()
    plt.savefig("var_breach_plot.png")
    plt.close()
    print("--> VaR breach plot saved to 'var_breach_plot.png'.")
    
    print("\n" + "="*80)
    print(">>> SCRIPT 04 FINISHED SUCCESSFULLY <<<")
    print("="*80 + "\n")